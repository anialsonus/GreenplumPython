"""
This module creates a Python object TableRowGroup for group by table.
"""
from collections import abc
from typing import TYPE_CHECKING, Callable, Iterable, List, MutableSet, Union

from greenplumpython.expr import Expr

if TYPE_CHECKING:
    from greenplumpython.func import FunctionExpr
    from greenplumpython.table import Table


class TableGroupingSets:
    """
    Represents a group of rows in a :class:`~table.Table` generated by :func:`~table.Table.group_by`.
    """

    def __init__(self, table: "Table", grouping_sets: List[Iterable["Expr"]]) -> None:
        self._table = table
        self._grouping_sets = grouping_sets

    def apply(self, func: Callable[["Table"], "FunctionExpr"]) -> "FunctionExpr":
        """
        Apply a function to the grouping set.

        Args:
            func: An aggregate function to be applied to

        Returns:
            FunctionExpr: a callable

        Example:
            .. code-block::  python

                numbers.group_by(lambda t: t["is_even"]).apply(lambda row: count(row["*"]))
        """
        return func(self._table).bind(group_by=self)

    def add(
        self, grouping_items: Callable[["Table"], Union["Expr", Iterable["Expr"]]]
    ) -> "TableGroupingSets":
        """
        Append another group defined by `grouping_items` on the same
        :class:`~table.Table` to the GROUPING SET so that when applying an
        agggregate function to the set, the function will be applied to each
        group individually.

        Args:
            grouping_items:
        """
        _grouping_items = grouping_items(self._table)
        return TableGroupingSets(
            self._table,
            self._grouping_sets
            + [_grouping_items if isinstance(_grouping_items, abc.Iterable) else [_grouping_items]],
        )

    def flatten(self) -> Iterable["Expr"]:
        """:meta private:"""
        item_set: MutableSet[Expr] = set()
        for grouping_set in self._grouping_sets:
            for group_by_item in grouping_set:
                assert isinstance(
                    group_by_item, Expr
                ), f"Grouping item {group_by_item} is not an 'Expr'"
                item_set.add(group_by_item)
        return item_set

    @property
    def table(self) -> "Table":
        """
        Returns :class:`~table.Table` associated for GROUP BY

        Returns:
            Table
        """
        return self._table

    # FIXME: Make this function package-private
    def clause(self) -> str:
        """:meta private:"""
        grouping_sets_str = [
            f"({','.join([item.as_name for item in grouping_set])})"
            for grouping_set in self._grouping_sets
        ]
        return "GROUP BY GROUPING SETS " + f"({','.join(grouping_sets_str)})"
